---
name: Add comprehensive coverage of GitHub CLI features used by PM system
status: open
created: 2025-08-25T14:20:00Z
updated: 
github: 
depends_on: [16]
parallel: true
conflicts_with: []
priority: high
type: feature
---

# Task: Add comprehensive coverage of GitHub CLI features used by PM system

## Description
Ensure REPOCLI wrapper provides complete coverage of all GitHub CLI features that our own project management system (`.claude/scripts/pm` and `.claude/commands/pm`) depends on. This critical task identifies and implements missing functionality that could break our PM workflows when using GitLab provider.

## Problem Analysis

Analysis of PM system revealed several **critical gaps** in REPOCLI wrapper coverage:

### Critical Missing Features

**1. Extension Command Framework**
- **Issue**: PM system uses `gh extension` and `gh sub-issue create` extensively
- **Impact**: Epic decomposition completely broken on GitLab provider
- **Current gap**: No `gitlab_extension_command()` function exists

**2. Advanced JSON Query Support**  
- **Issue**: Complex `-q .field` patterns not properly translated
- **Examples**: `--json number -q .number`, `--json nameWithOwner -q .nameWithOwner`
- **Impact**: PM automation scripts fail with JSON parsing errors

**3. Assignee Management**
- **Issue**: `--add-assignee @me`, `--remove-assignee` not translated
- **Impact**: Task assignment workflow broken on GitLab

**4. Sub-Issue Relationships**
- **Issue**: `gh sub-issue create --parent X` has no GitLab equivalent
- **Impact**: Epic parent/child relationships not working

## PM System Usage Analysis

### Authentication Commands (✅ Already Covered)
```bash
gh auth status          # → glab auth status (working)
gh auth login           # → glab auth login (working)
```

### Issue Commands (⚠️ Partially Covered)
```bash
# Working in current REPOCLI
gh issue view #N --json state,title,labels,body
gh issue create --title "X" --body-file Y --label "Z"
gh issue edit #N --title "X" --body-file Y
gh issue close #N --comment "X"

# Missing in current REPOCLI  
gh issue edit #N --add-assignee @me --add-label "in-progress"
gh issue edit #N --remove-assignee --remove-label "old-label"
```

### Extension Commands (❌ Not Covered)
```bash
# Used extensively in epic-sync.md
gh extension list
gh extension install yahsan2/gh-sub-issue  
gh sub-issue create --parent N --title "X" --body-file Y --label "Z"
```

### Complex JSON Queries (⚠️ Needs Enhancement)
```bash
# Used in multiple PM commands
gh issue create --json number -q .number
gh repo view --json nameWithOwner -q .nameWithOwner
gh issue view #N --json body -q .body
```

## Acceptance Criteria

### Extension Command Support
- [ ] Implement `gitlab_extension_command()` function
- [ ] Add extension installation detection and warnings
- [ ] Create sub-issue simulation using GitLab issue relationships
- [ ] Handle `gh sub-issue create --parent X` with native GitLab links

### Enhanced JSON Query Support
- [ ] Improve `-q .field` pattern parsing in all GitLab provider functions
- [ ] Support complex jq queries: `--json number -q .number`
- [ ] Maintain output format consistency with GitHub CLI
- [ ] Handle nested JSON field queries properly

### Assignee Management
- [ ] Add `--add-assignee`/`--remove-assignee` parameter translation
- [ ] Support `@me` syntax resolution to current GitLab user
- [ ] Handle multiple assignees correctly
- [ ] Map GitHub assignee format to GitLab format

### Sub-Issue Relationship Simulation
- [ ] Create parent-child relationship tracking via GitLab issue links
- [ ] Implement `gitlab_sub_issue_create()` function
- [ ] Maintain compatibility with PM system's parent/child logic
- [ ] Handle relationship queries for epic management

## Implementation Requirements

### 1. Extension Command Framework

```bash
# In lib/providers/gitlab.sh
gitlab_extension_command() {
    local subcmd="$1"; shift
    
    case "$subcmd" in
        "list")
            echo "GitLab provider: extensions not supported, using native functionality"
            return 0
            ;;
        "install")
            local extension="$1"
            case "$extension" in
                "yahsan2/gh-sub-issue")
                    echo "GitLab provider: sub-issue functionality available via native issue links"
                    return 0
                    ;;
                *)
                    echo "GitLab provider: extension $extension not supported" >&2
                    return 1
                    ;;
            esac
            ;;
        *)
            echo "GitLab provider: extension command $subcmd not supported" >&2
            return 1
            ;;
    esac
}
```

### 2. Sub-Issue Creation Simulation

```bash
# Simulate gh sub-issue create using GitLab issue links
gitlab_sub_issue_create() {
    local parent_issue="" title="" body_file="" labels=""
    
    # Parse sub-issue arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            "--parent") parent_issue="$2"; shift 2 ;;
            "--title") title="$2"; shift 2 ;;
            "--body-file") body_file="$2"; shift 2 ;;
            "--label") labels="$2"; shift 2 ;;
            *) shift ;;
        esac
    done
    
    # Create issue with GitLab
    local create_args=()
    [[ -n "$title" ]] && create_args+=(--title "$title")
    [[ -n "$body_file" ]] && create_args+=(--description-file "$body_file") 
    [[ -n "$labels" ]] && create_args+=(--label "$labels")
    
    local issue_url=$(glab issue create "${create_args[@]}")
    local issue_number=$(echo "$issue_url" | grep -oE '[0-9]+$')
    
    # Create relationship link if parent specified
    if [[ -n "$parent_issue" ]]; then
        # Use GitLab issue links API to create parent relationship
        glab api projects/$PROJECT_ID/issues/$issue_number/links -X POST \
            -d issue_id="$parent_issue" -d link_type="relates_to" >/dev/null 2>&1 || true
        
        # Add parent reference to issue description for visibility
        local parent_note="Related to parent issue #$parent_issue"
        glab issue note "$issue_number" --message "$parent_note" >/dev/null 2>&1 || true
    fi
    
    # Return issue number in GitHub CLI compatible format
    echo "{\"number\": $issue_number}"
}
```

### 3. Enhanced JSON Query Processing

```bash
# Improve JSON query handling in gitlab_issue_view
gitlab_issue_view() {
    local issue="$1"; shift
    local json_fields="" query=""
    local glab_args=()
    
    # Parse arguments for JSON output and queries
    while [[ $# -gt 0 ]]; do
        case "$1" in
            "--json")
                json_fields="$2"
                shift 2
                ;;
            "-q")
                query="$2"
                shift 2
                ;;
            *)
                glab_args+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ -n "$json_fields" ]]; then
        # Get raw JSON from GitLab
        local raw_output=$(glab issue view "$issue" "${glab_args[@]}" --output json)
        
        # Normalize GitLab fields to GitHub field names
        local normalized=$(echo "$raw_output" | jq '
            .number = .iid |
            .state = (if .state == "opened" then "open" else .state end) |
            if .labels then .labels = [.labels[] | {name: .}] else . end
        ')
        
        # Apply field selection if specified
        if [[ "$json_fields" != "." ]]; then
            # Convert comma-separated fields to jq selector
            local fields_selector=$(echo "$json_fields" | sed 's/,/", "/g' | sed 's/^/{"/' | sed 's/$/"}/') 
            normalized=$(echo "$normalized" | jq "with_entries(select(.key as \$k | [\"$(echo "$json_fields" | sed 's/,/", "/g')\"] | index(\$k)))")
        fi
        
        # Apply query if specified
        if [[ -n "$query" ]]; then
            echo "$normalized" | jq -r "$query"
        else
            echo "$normalized"
        fi
    else
        # Regular text output
        glab issue view "$issue" "${glab_args[@]}"
    fi
}
```

### 4. Assignee Management

```bash
# Add assignee support to gitlab_issue_edit
gitlab_issue_edit() {
    local issue="$1"; shift
    local add_assignees=() remove_assignees=()
    local glab_args=()
    
    # Parse assignee arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            "--add-assignee")
                local assignee="$2"
                [[ "$assignee" == "@me" ]] && assignee=$(glab auth status | grep -o "Logged in.*as \\w*" | awk '{print $NF}')
                add_assignees+=("$assignee")
                shift 2
                ;;
            "--remove-assignee")
                local assignee="$2"
                [[ "$assignee" == "@me" ]] && assignee=$(glab auth status | grep -o "Logged in.*as \\w*" | awk '{print $NF}')
                remove_assignees+=("$assignee")
                shift 2
                ;;
            *)
                glab_args+=("$1")
                shift
                ;;
        esac
    done
    
    # Apply assignee changes
    for assignee in "${add_assignees[@]}"; do
        glab_args+=(--assignee "$assignee")
    done
    
    # GitLab doesn't have direct unassign, but we can reassign to empty or other users
    # This is a limitation we'll document
    
    glab issue edit "$issue" "${glab_args[@]}"
}
```

## Cross-Testing Integration

### PM System Compatibility Tests
```bash
# Test extension command handling
test_extension_commands() {
    # Test extension list (should not fail)
    repocli extension list >/dev/null 2>&1 || echo "Expected: extension list handled gracefully"
    
    # Test sub-issue creation simulation
    if [[ "$gitlab_test_mode" != "read_only" ]]; then
        local parent_issue=$(get_test_issue)
        local sub_issue=$(repocli sub-issue create --parent "$parent_issue" --title "Test sub-issue")
        
        # Verify relationship exists in GitLab
        local links=$(glab issue view "$parent_issue" --output json | jq '.links.related_issues // []')
        assert_not_empty "$links" "Sub-issue relationship should exist"
        
        echo "✅ Sub-issue creation simulation working"
    fi
}

# Test advanced JSON queries
test_json_query_patterns() {
    local test_issue=$(get_test_issue)
    [[ "$test_issue" == "SKIP" ]] && return 0
    
    # Test complex query patterns used by PM system
    local issue_number=$(repocli issue view "$test_issue" --json number -q .number)
    assert_equals "$issue_number" "$test_issue" "JSON query should return issue number"
    
    local repo_name=$(repocli repo view --json nameWithOwner -q .nameWithOwner)
    assert_not_empty "$repo_name" "Repo query should return nameWithOwner"
    
    echo "✅ JSON query patterns working"
}
```

## Dependencies
- [ ] Task 16: Wrapper option handling fixes (completed)
- [ ] Understanding of GitLab API for issue relationships
- [ ] Analysis of PM system's exact requirements

## Effort Estimate
- Size: L
- Hours: 20-28 hours
- Priority: High (blocks PM system GitLab compatibility)

## Definition of Done
- [ ] All `gh` commands used by PM system work through REPOCLI wrapper
- [ ] Extension commands handled gracefully (with fallbacks or simulation)
- [ ] JSON query patterns (`-q .field`) work correctly on GitLab provider
- [ ] Sub-issue functionality simulated using GitLab issue relationships
- [ ] Assignee management working with GitLab users
- [ ] PM system workflows (epic sync, issue management) work end-to-end on GitLab
- [ ] Cross-testing validates PM system compatibility

## Critical Impact Statement

**This task is essential for REPOCLI adoption**. Our own PM system is the primary user of GitHub CLI features - if REPOCLI can't handle our own workflows, it can't be trusted for external users. This represents a "eat your own dog food" validation of the wrapper's completeness.

## Usage Examples

```bash
# PM system compatibility
repocli extension list                    # Graceful handling
repocli sub-issue create --parent 123 --title "Task"  # GitLab simulation
repocli issue edit 456 --add-assignee @me            # Assignee support
repocli issue view 789 --json number -q .number      # Complex JSON queries

# Verify PM commands work
/pm:epic-sync cross-testing              # Should work on GitLab
/pm:issue-create "New task"              # Should work on GitLab  
/pm:issue-start 123                      # Should assign on GitLab
```

This task ensures our wrapper isn't just a proof-of-concept, but a production-ready tool that can handle sophisticated automation workflows.