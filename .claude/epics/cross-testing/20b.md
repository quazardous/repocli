---
name: Enhance JSON query support for complex -q patterns
status: open
created: 2025-08-25T14:30:00Z
updated: 
github: 
depends_on: [20]
parallel: true
conflicts_with: []
priority: high
type: feature
---

# Task 20b: Enhance JSON query support for complex -q patterns

## Description
Improve REPOCLI wrapper's JSON output and query support to handle complex `-q .field` patterns used extensively by PM system. Current implementation only handles basic JSON output but fails on sophisticated jq queries.

## Problem Statement
PM system uses advanced JSON query patterns that currently fail:
```bash
gh issue create --json number -q .number           # Returns issue number only
gh repo view --json nameWithOwner -q .nameWithOwner  # Returns repo path only  
gh issue view #N --json body,title -q '.body, .title'  # Multiple fields
```

Current GitLab provider only supports basic `--output json`, missing the crucial `-q` query functionality.

## Acceptance Criteria

### Enhanced JSON Field Selection
- [ ] Support `--json field1,field2` field selection
- [ ] Handle single field queries: `--json number`
- [ ] Handle multiple field queries: `--json number,title,state`
- [ ] Maintain GitHub CLI field name compatibility

### Advanced Query Processing
- [ ] Support `-q .field` single field extraction
- [ ] Support `-q '.field1, .field2'` multiple field extraction  
- [ ] Handle nested field queries: `-q .assignee.login`
- [ ] Support conditional queries: `-q 'if .state == "open" then .number else empty end'`

### Field Normalization
- [ ] Map GitLab field names to GitHub equivalents
- [ ] Handle missing fields gracefully (return null/empty)
- [ ] Preserve GitHub CLI output format exactly
- [ ] Support all fields used by PM system

## PM System Field Usage Analysis

### Most Critical Fields (used by PM commands)
```bash
# Issue fields
--json number -q .number                    # Issue number extraction
--json state,title,labels,body              # Issue overview
--json body -q .body                        # Body content only
--json labels -q '.labels[].name'           # Label names array
--json updatedAt -q .updatedAt              # Last update timestamp

# Repository fields  
--json nameWithOwner -q .nameWithOwner      # Full repo path
--json defaultBranchRef -q .defaultBranchRef.name  # Default branch

# Authentication
--json login -q .login                      # Current user
```

## Implementation Details

### 1. Enhanced JSON Field Mapping
```bash
# Field name translation GitLab → GitHub
normalize_gitlab_json_fields() {
    local json="$1"
    echo "$json" | jq '
        # Issue field mappings
        .number = .iid |
        .state = (if .state == "opened" then "open" else .state end) |
        .labels = (if .labels then [.labels[] | if type == "string" then {name: .} else . end] else [] end) |
        .body = .description |
        .updatedAt = .updated_at |
        .createdAt = .created_at |
        
        # User field mappings
        .login = .username |
        .assignees = (if .assignees then [.assignees[] | {login: .username}] else [] end) |
        
        # Repository field mappings (when applicable)
        .nameWithOwner = (.namespace.full_path + "/" + .name) |
        .defaultBranchRef = {name: .default_branch}
    '
}
```

### 2. Query Processing Engine
```bash
# Enhanced gitlab_issue_view with full query support
gitlab_issue_view() {
    local issue="$1"; shift
    local json_fields="" query="" output_format="text"
    local glab_args=()
    
    # Parse GitHub CLI style arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            "--json")
                json_fields="$2"
                output_format="json"
                shift 2
                ;;
            "-q"|"--jq")
                query="$2"
                shift 2
                ;;
            "--web")
                glab_args+=(--web)
                shift
                ;;
            *)
                glab_args+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ "$output_format" == "json" ]]; then
        # Get raw GitLab JSON
        local raw_json=$(glab issue view "$issue" --output json "${glab_args[@]}")
        
        # Normalize field names
        local normalized_json=$(normalize_gitlab_json_fields "$raw_json")
        
        # Apply field selection if specified
        if [[ -n "$json_fields" && "$json_fields" != "." ]]; then
            # Convert comma-separated fields to jq selector
            local field_array=$(echo "$json_fields" | tr ',' '\n' | sed 's/^/"/;s/$/"/' | tr '\n' ',' | sed 's/,$//')
            local field_selector="{$(echo "$json_fields" | sed 's/,/: .,/g'): .}"
            normalized_json=$(echo "$normalized_json" | jq "$field_selector")
        fi
        
        # Apply jq query if specified
        if [[ -n "$query" ]]; then
            echo "$normalized_json" | jq -r "$query"
        else
            echo "$normalized_json"
        fi
    else
        # Regular text output
        glab issue view "$issue" "${glab_args[@]}"
    fi
}
```

### 3. Repository Command JSON Support
```bash
gitlab_repo_command() {
    local subcmd="$1"; shift
    
    case "$subcmd" in
        "view")
            local json_fields="" query=""
            local repo_args=()
            
            # Parse arguments
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    "--json")
                        json_fields="$2"
                        shift 2
                        ;;
                    "-q"|"--jq")
                        query="$2"  
                        shift 2
                        ;;
                    *)
                        repo_args+=("$1")
                        shift
                        ;;
                esac
            done
            
            if [[ -n "$json_fields" ]]; then
                # Get GitLab repo JSON
                local raw_json=$(glab repo view --output json "${repo_args[@]}")
                local normalized=$(normalize_gitlab_repo_json "$raw_json")
                
                # Apply field selection and query
                if [[ "$json_fields" != "." ]]; then
                    local field_selector="{$(echo "$json_fields" | sed 's/,/: .,/g'): .}"
                    normalized=$(echo "$normalized" | jq "$field_selector")
                fi
                
                if [[ -n "$query" ]]; then
                    echo "$normalized" | jq -r "$query"
                else
                    echo "$normalized"
                fi
            else
                glab repo view "${repo_args[@]}"
            fi
            ;;
        *)
            echo "Repo command $subcmd not implemented" >&2
            return 1
            ;;
    esac
}
```

### 4. Issue Creation with JSON Output
```bash
# Enhance gitlab_issue_create to support JSON output
gitlab_issue_create() {
    # ... existing parameter parsing ...
    local json_output=false query=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            "--json")
                json_output=true
                json_fields="$2"
                shift 2
                ;;
            "-q"|"--jq")
                query="$2"
                shift 2
                ;;
            # ... other parameters ...
        esac
    done
    
    # Create issue and get response
    if [[ "$json_output" == true ]]; then
        local issue_url=$(glab issue create "${glab_args[@]}")
        local issue_number=$(echo "$issue_url" | grep -oE '[0-9]+$')
        
        # Fetch created issue details in JSON
        local issue_json=$(glab issue view "$issue_number" --output json)
        local normalized=$(normalize_gitlab_json_fields "$issue_json")
        
        # Apply field selection and query
        if [[ -n "$json_fields" && "$json_fields" != "." ]]; then
            local field_selector="{$(echo "$json_fields" | sed 's/,/: .,/g'): .}"
            normalized=$(echo "$normalized" | jq "$field_selector")
        fi
        
        if [[ -n "$query" ]]; then
            echo "$normalized" | jq -r "$query"
        else
            echo "$normalized"
        fi
    else
        glab issue create "${glab_args[@]}"
    fi
}
```

## Testing Strategy

### Field Mapping Tests
```bash
test_json_field_normalization() {
    local test_issue=$(get_test_issue)
    [[ "$test_issue" == "SKIP" ]] && return 0
    
    # Test basic field mapping
    local gh_state=$(gh issue view "$test_issue" --json state -q .state)
    local repocli_state=$(repocli issue view "$test_issue" --json state -q .state)
    assert_equals "$gh_state" "$repocli_state" "State field should match"
    
    # Test number field mapping (iid → number)
    local repocli_number=$(repocli issue view "$test_issue" --json number -q .number)
    assert_equals "$repocli_number" "$test_issue" "Number field should match issue ID"
    
    echo "✅ JSON field normalization working"
}

test_complex_queries() {
    local test_issue=$(get_test_issue)
    [[ "$test_issue" == "SKIP" ]] && return 0
    
    # Test PM system's most common query pattern
    local issue_number=$(repocli issue view "$test_issue" --json number -q .number)
    assert_matches "$issue_number" '^[0-9]+$' "Should extract numeric issue ID"
    
    # Test multiple field selection
    local multi_output=$(repocli issue view "$test_issue" --json number,title,state)
    assert_contains "$multi_output" '"number"' "Should include number field"
    assert_contains "$multi_output" '"title"' "Should include title field" 
    assert_contains "$multi_output" '"state"' "Should include state field"
    
    echo "✅ Complex JSON queries working"
}
```

## PM System Integration Points

### Commands that will benefit:
- `/pm:epic-sync` - Heavy JSON processing for issue analysis
- `/pm:issue-create` - Needs `--json number -q .number` for issue ID extraction
- `/pm:repo-info` - Uses `--json nameWithOwner -q .nameWithOwner`
- All issue management commands using JSON output

## Dependencies
- Task 20: Main PM system coverage analysis
- Understanding of jq query syntax and edge cases
- Access to test repositories for validation

## Definition of Done
- [ ] All JSON field selections work: `--json field1,field2`
- [ ] All query patterns work: `-q .field`, `-q '.field1, .field2'`
- [ ] Field name normalization complete (GitLab ↔ GitHub)
- [ ] PM system JSON queries work identically on both providers
- [ ] Complex nested queries handled correctly
- [ ] Error handling for invalid queries/fields
- [ ] Performance acceptable for large JSON responses

## Effort Estimate
- Size: M-L  
- Hours: 12-16 hours
- High impact for PM system automation reliability